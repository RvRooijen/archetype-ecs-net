<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>archetype-ecs-net RPG Demo</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; display: flex; justify-content: center; align-items: center; height: 100vh; height: 100dvh; font-family: monospace; overflow: hidden; touch-action: none; }
  canvas { cursor: crosshair; image-rendering: pixelated; display: block; width: 100vw; height: 100vh; height: 100dvh; }
  #ctx-menu { position: fixed; background: #2a2a3e; border: 1px solid #555; color: #eee; font-size: 15px; display: none; z-index: 10; min-width: 140px; border-radius: 4px; }
  #ctx-menu div { padding: 10px 14px; cursor: pointer; }
  #ctx-menu div:hover, #ctx-menu div:active { background: #3a3a5e; }
  #hud { position: fixed; top: 8px; left: 8px; color: #eee; font-size: 12px; background: rgba(0,0,0,0.6); padding: 5px 8px; border-radius: 3px; pointer-events: none; }
</style>
</head>
<body>
<div id="hud">Connecting...</div>
<canvas id="c"></canvas>
<div id="ctx-menu"></div>
<script>
// ── Constants (must match server) ───────────────────────
const WORLD = 64;
const KIND_PLAYER = 1, KIND_TREE = 2, KIND_ROCK = 3, KIND_NPC = 4;
const INPUT_MOVE = 1, INPUT_INTERACT = 2;
const ACTION_CHOP = 1, ACTION_MINE = 2, ACTION_EXAMINE = 3;

// ── Responsive sizing ────────────────────────────────────
let TILE, VIEW_W, VIEW_H;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  const dpr = window.devicePixelRatio || 1;
  const w = window.innerWidth;
  const h = window.innerHeight;
  // Pick tile size so we get at least 10 tiles across on small screens
  TILE = Math.max(24, Math.min(48, Math.floor(Math.min(w, h) / 12)));
  VIEW_W = Math.ceil(w / TILE);
  VIEW_H = Math.ceil(h / TILE);
  canvas.width = VIEW_W * TILE;
  canvas.height = VIEW_H * TILE;
}
resize();
window.addEventListener('resize', resize);

// ── State ───────────────────────────────────────────────
let tileMap = null;
let myNetId = -1;
let entities = new Map(); // netId → {x, y, kind, hp, maxHp, variant}
const hud = document.getElementById('hud');
const ctxMenu = document.getElementById('ctx-menu');

// ── Inline Protocol Decoder (MSG_FULL = 0x01) ──────────

function readVarint(view, o) {
  let v = 0, shift = 0, b;
  do { b = view.getUint8(o.p++); v |= (b & 0x7F) << shift; shift += 7; } while (b >= 0x80);
  return v >>> 0;
}

function decodeFullState(buf) {
  const view = new DataView(buf);
  const o = { p: 1 }; // skip msg type byte
  const count = view.getUint16(o.p, true); o.p += 2;
  const result = new Map();

  for (let e = 0; e < count; e++) {
    const netId = readVarint(view, o);
    const compCount = view.getUint8(o.p++);
    const ent = { x: 0, y: 0, kind: 0, hp: 0, maxHp: 0, variant: 0 };

    for (let c = 0; c < compCount; c++) {
      const wireId = view.getUint8(o.p++);
      switch (wireId) {
        case 0: // Position: i16 x, i16 y
          ent.x = view.getInt16(o.p, true); o.p += 2;
          ent.y = view.getInt16(o.p, true); o.p += 2;
          break;
        case 1: // EntityType: u8 kind
          ent.kind = view.getUint8(o.p++);
          break;
        case 2: // Health: i16 current, i16 max
          ent.hp = view.getInt16(o.p, true); o.p += 2;
          ent.maxHp = view.getInt16(o.p, true); o.p += 2;
          break;
        case 3: // Appearance: u8 variant
          ent.variant = view.getUint8(o.p++);
          break;
      }
    }
    result.set(netId, ent);
  }
  return result;
}

// ── WebSocket ───────────────────────────────────────────

let ws = null;
function connect() {
  ws = new WebSocket('ws://localhost:9001');
  ws.binaryType = 'arraybuffer';

  ws.onopen = () => { hud.textContent = 'Connected'; };
  ws.onclose = () => { hud.textContent = 'Disconnected — refreshing...'; setTimeout(() => location.reload(), 2000); };

  ws.onmessage = (e) => {
    const buf = e.data;
    const type = new Uint8Array(buf)[0];

    if (type === 0xFE) { // tile map
      const size = new Uint8Array(buf)[1];
      tileMap = new Uint8Array(buf, 2, size * size);
    } else if (type === 0xFD) { // player id
      myNetId = new DataView(buf).getUint16(1, true);
    } else if (type === 0x01) { // full state
      entities = decodeFullState(buf);
    }
  };
}
connect();

// ── Input ───────────────────────────────────────────────

function sendMove(tx, ty) {
  if (!ws || ws.readyState !== 1) return;
  const buf = new ArrayBuffer(5);
  const v = new DataView(buf);
  v.setUint8(0, INPUT_MOVE);
  v.setInt16(1, tx, true);
  v.setInt16(3, ty, true);
  ws.send(buf);
}

function sendInteract(tx, ty, action) {
  if (!ws || ws.readyState !== 1) return;
  const buf = new ArrayBuffer(6);
  const v = new DataView(buf);
  v.setUint8(0, INPUT_INTERACT);
  v.setInt16(1, tx, true);
  v.setInt16(3, ty, true);
  v.setUint8(5, action);
  ws.send(buf);
}

function pointToTile(cx, cy) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (cx - rect.left) * scaleX;
  const my = (cy - rect.top) * scaleY;
  const me = entities.get(myNetId);
  if (!me) return null;
  const camX = me.x - (VIEW_W / 2 | 0);
  const camY = me.y - (VIEW_H / 2 | 0);
  return { x: (mx / TILE | 0) + camX, y: (my / TILE | 0) + camY };
}

function entityAtTile(tx, ty) {
  for (const [netId, e] of entities) {
    if (e.x === tx && e.y === ty && netId !== myNetId) return e;
  }
  return null;
}

// Left click: walk to tile
canvas.addEventListener('click', (e) => {
  hideContextMenu();
  const t = pointToTile(e.clientX, e.clientY);
  if (t) sendMove(t.x, t.y);
});

// Right click: context menu
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const t = pointToTile(e.clientX, e.clientY);
  if (!t) return;
  showContextMenu(e.clientX, e.clientY, t);
});

// ── Touch input (tap = move, long press = context menu) ──
let touchTimer = null;
let touchStartPos = null;
const LONG_PRESS_MS = 400;
const TAP_MOVE_THRESHOLD = 10;

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  hideContextMenu();
  if (e.touches.length !== 1) return;
  const touch = e.touches[0];
  touchStartPos = { x: touch.clientX, y: touch.clientY };
  touchTimer = setTimeout(() => {
    touchTimer = null;
    const t = pointToTile(touchStartPos.x, touchStartPos.y);
    if (t) showContextMenu(touchStartPos.x, touchStartPos.y, t);
  }, LONG_PRESS_MS);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!touchStartPos || e.touches.length !== 1) return;
  const touch = e.touches[0];
  const dx = touch.clientX - touchStartPos.x;
  const dy = touch.clientY - touchStartPos.y;
  if (Math.abs(dx) + Math.abs(dy) > TAP_MOVE_THRESHOLD) {
    clearTimeout(touchTimer);
    touchTimer = null;
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (touchTimer) {
    clearTimeout(touchTimer);
    touchTimer = null;
    // Short tap = move
    if (touchStartPos) {
      const t = pointToTile(touchStartPos.x, touchStartPos.y);
      if (t) sendMove(t.x, t.y);
    }
  }
  touchStartPos = null;
}, { passive: false });

function showContextMenu(mx, my, tile) {
  ctxMenu.innerHTML = '';
  const ent = entityAtTile(tile.x, tile.y);

  const addOption = (label, fn) => {
    const div = document.createElement('div');
    div.textContent = label;
    div.onclick = () => { fn(); hideContextMenu(); };
    ctxMenu.appendChild(div);
  };

  if (ent && ent.kind === KIND_TREE) {
    addOption('Chop tree', () => sendInteract(tile.x, tile.y, ACTION_CHOP));
    addOption('Examine', () => sendInteract(tile.x, tile.y, ACTION_EXAMINE));
  } else if (ent && ent.kind === KIND_ROCK) {
    addOption('Mine rock', () => sendInteract(tile.x, tile.y, ACTION_MINE));
    addOption('Examine', () => sendInteract(tile.x, tile.y, ACTION_EXAMINE));
  } else if (ent && ent.kind === KIND_NPC) {
    addOption('Examine', () => sendInteract(tile.x, tile.y, ACTION_EXAMINE));
  } else if (ent && ent.kind === KIND_PLAYER) {
    addOption('Examine', () => sendInteract(tile.x, tile.y, ACTION_EXAMINE));
  } else {
    addOption('Walk here', () => sendMove(tile.x, tile.y));
  }
  addOption('Cancel', () => {});

  ctxMenu.style.left = mx + 'px';
  ctxMenu.style.top = my + 'px';
  ctxMenu.style.display = 'block';
}

function hideContextMenu() { ctxMenu.style.display = 'none'; }
document.addEventListener('click', (e) => { if (e.target !== ctxMenu && !ctxMenu.contains(e.target)) hideContextMenu(); });
document.addEventListener('touchstart', (e) => { if (e.target !== ctxMenu && !ctxMenu.contains(e.target)) hideContextMenu(); }, { passive: true });

// Keyboard as fallback
document.addEventListener('keydown', (e) => {
  const me = entities.get(myNetId);
  if (!me) return;
  let dx = 0, dy = 0;
  if (e.key === 'ArrowUp' || e.key === 'w') dy = -1;
  else if (e.key === 'ArrowDown' || e.key === 's') dy = 1;
  else if (e.key === 'ArrowLeft' || e.key === 'a') dx = -1;
  else if (e.key === 'ArrowRight' || e.key === 'd') dx = 1;
  else return;
  sendMove(me.x + dx, me.y + dy);
});

// ── Rendering ───────────────────────────────────────────

const TILE_COLORS = ['#4a7c3f', '#2a5a9e', '#8b7355'];
const PLAYER_COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'];
const TREE_GREENS = ['#2d6b22', '#1e8c1e', '#3a8a2e'];
const ROCK_GRAYS = ['#888', '#999', '#777'];
const NPC_COLORS = ['#e6c74c', '#d4a040', '#c4943a', '#b8883a'];

function render() {
  const cw = canvas.width, ch = canvas.height;
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, cw, ch);

  if (!tileMap) { requestAnimationFrame(render); return; }

  const me = entities.get(myNetId);
  const camX = me ? me.x - (VIEW_W / 2 | 0) : 0;
  const camY = me ? me.y - (VIEW_H / 2 | 0) : 0;

  // Draw tiles
  for (let dy = 0; dy < VIEW_H + 1; dy++) {
    for (let dx = 0; dx < VIEW_W + 1; dx++) {
      const tx = camX + dx, ty = camY + dy;
      if (tx < 0 || ty < 0 || tx >= WORLD || ty >= WORLD) continue;
      ctx.fillStyle = TILE_COLORS[tileMap[ty * WORLD + tx]] || '#000';
      ctx.fillRect(dx * TILE, dy * TILE, TILE, TILE);
      // Grid lines
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.strokeRect(dx * TILE, dy * TILE, TILE, TILE);
    }
  }

  // Draw entities
  for (const [netId, e] of entities) {
    const sx = (e.x - camX) * TILE;
    const sy = (e.y - camY) * TILE;
    if (sx < -TILE || sy < -TILE || sx > cw || sy > ch) continue;

    const isMe = netId === myNetId;

    const T = TILE; // alias for readability
    const half = T / 2;
    const pad = T * 0.125; // ~12.5% inset

    switch (e.kind) {
      case KIND_PLAYER:
        ctx.fillStyle = PLAYER_COLORS[e.variant] || '#fff';
        ctx.fillRect(sx + pad, sy + pad, T - pad * 2, T - pad * 2);
        if (isMe) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.strokeRect(sx + pad - 1, sy + pad - 1, T - pad * 2 + 2, T - pad * 2 + 2);
          ctx.lineWidth = 1;
        }
        break;

      case KIND_TREE:
        ctx.fillStyle = '#6b4423';
        ctx.fillRect(sx + T * 0.375, sy + T * 0.56, T * 0.25, T * 0.44);
        ctx.fillStyle = TREE_GREENS[e.variant] || '#2d6b22';
        ctx.beginPath();
        ctx.arc(sx + half, sy + T * 0.44, T * 0.34, 0, Math.PI * 2);
        ctx.fill();
        break;

      case KIND_ROCK:
        ctx.fillStyle = ROCK_GRAYS[e.variant] || '#888';
        ctx.beginPath();
        ctx.moveTo(sx + T * 0.19, sy + T * 0.81);
        ctx.lineTo(sx + half, sy + T * 0.19);
        ctx.lineTo(sx + T * 0.875, sy + T * 0.69);
        ctx.lineTo(sx + T * 0.625, sy + T * 0.875);
        ctx.closePath();
        ctx.fill();
        break;

      case KIND_NPC:
        ctx.fillStyle = NPC_COLORS[e.variant] || '#e6c74c';
        ctx.fillRect(sx + pad * 1.5, sy + pad * 1.5, T - pad * 3, T - pad * 3);
        ctx.fillStyle = '#000';
        ctx.font = `${Math.round(T * 0.25)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('NPC', sx + half, sy + T * 0.625);
        break;
    }

    // Health bar (not for full HP)
    if (e.hp < e.maxHp && e.hp > 0) {
      const bw = T - pad * 2;
      ctx.fillStyle = '#333';
      ctx.fillRect(sx + pad, sy - pad, bw, pad);
      ctx.fillStyle = '#2ecc71';
      ctx.fillRect(sx + pad, sy - pad, (e.hp / e.maxHp) * bw, pad);
    }
  }

  // HUD
  if (me) {
    hud.textContent = `Pos: ${me.x}, ${me.y}  |  HP: ${me.hp}/${me.maxHp}  |  Entities: ${entities.size}`;
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
